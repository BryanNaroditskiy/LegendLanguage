Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import re\r\n\r\n# Token types\r\nkeywords = {\r\n    'true', 'false', 'avg', 'max', 'min', 'sort', 'shuffle', 'reverse', 'union', 'intersection',\r\n    'sin', 'cos', 'tan', 'sqrt', 'random', 'lambda', 'if', 'else', 'repeat', 'time',\r\n    'acceleration', 'momentum', 'gravity', 'kinetic_energy', 'potential_energy', 'work', 'power',\r\n    'impulse', 'torque', 'angular_velocity', 'angular_acceleration', 'friction', 'pressure',\r\n    'density', 'moment_of_inertia', 'spring_constant', 'frequency', 'wavelength'\r\n}\r\n\r\noperators = {'+', '-', '*', '/', '^', '%', '=', '!=', '>', '<', '>=', '<=', '&&', '||', '!', '(', ')'}\r\n\r\n# Regular expressions\r\nidentifier_regex = r'[a-zA-Z_][a-zA-Z0-9_]*'\r\nnumber_regex = r'\\d+'\r\nstring_regex = r'\"(?:[^\"\\\\]|\\\\.)*\"'\r\ncomment_regex = r';.*'\r\nwhitespace_regex = r'\\s+'\r\n\r\ntoken_regex = re.compile(f'({identifier_regex}|{number_regex}|{string_regex}|'\r\n                         f'{\"|\".join(map(re.escape, operators))}|{whitespace_regex}|{comment_regex})')\r\n\r\n\r\ndef lex(code):\r\n    tokens = []\r\n    for match in re.finditer(token_regex, code):\r\n        token = match.group().strip()\r\n        if token:\r\n            if token[0] == ';':  # Ignore comments\r\n                continue\r\n            elif token in keywords:\r\n                tokens.append(('KEYWORD', token))\r\n            elif token in operators:\r\n                tokens.append(('OPERATOR', token))\r\n            elif re.match(number_regex, token):\r\n                tokens.append(('NUMBER', token))\r\n            elif re.match(r'\"[^\"]*\"', token):  # Adjusted to recognize string literals\r\n                tokens.append(('STRING', token[1:-1]))  # Remove quotes\r\n            else:\r\n                tokens.append(('IDENTIFIER', token))\r\n    return tokens\r\n\r\n\r\nclass Parser:\r\n    def __init__(self, tokens):\r\n        self.tokens = tokens\r\n        self.current_token_idx = 0\r\n\r\n    def parse(self):\r\n        statements = []\r\n        while self.current_token_idx < len(self.tokens):\r\n            print(\"Current token:\", self.tokens[self.current_token_idx])\r\n            statement = self.parse_statement()\r\n            if statement:\r\n                statements.append(statement)\r\n        return statements\r\n\r\n    def parse_statement(self):\r\n        token_type, token_value = self.peek()\r\n        print(\"Current token in parse_statement:\", token_type, token_value)\r\n        if token_type == 'KEYWORD':\r\n            if token_value == 'print':\r\n                return self.parse_print_statement()\r\n            elif token_value == 'if':\r\n                return self.parse_if_statement()\r\n            elif token_value == 'repeat':\r\n                return self.parse_repeat_statement()\r\n            else:\r\n                # Handle other keyword statements\r\n                pass\r\n        elif token_type == 'IDENTIFIER':\r\n            return self.parse_assignment_statement()\r\n        else:\r\n            self.error(\"Unexpected token\")\r\n\r\n    def parse_print_statement(self):\r\n        self.consume('KEYWORD', 'print')\r\n        values = []\r\n        while self.peek()[0] != 'COMMENT':\r\n            token_type, token_value = self.peek()\r\n            if token_type == 'STRING' or token_type == 'NUMBER':\r\n                values.append(token_value)\r\n            elif token_type == 'IDENTIFIER':\r\n                values.append(token_value)\r\n            else:\r\n                self.error(\"Unexpected token in print statement\")\r\n            self.advance()\r\n        return ('PRINT', values)\r\n\r\n    def parse_if_statement(self):\r\n        self.consume('KEYWORD', 'if')\r\n        condition = self.parse_expression()\r\n        block = self.parse_block()\r\n        return ('IF', condition, block)\r\n\r\n    def parse_repeat_statement(self):\r\n        self.consume('KEYWORD', 'repeat')\r\n        times = self.parse_expression()\r\n        block = self.parse_block()\r\n        return ('REPEAT', times, block)\r\n\r\n    def parse_assignment_statement(self):\r\n        identifier = self.consume('IDENTIFIER')[1]\r\n        self.consume('OPERATOR', '=')\r\n        value = self.parse_expression()  # Parse expression instead of NUMBER\r\n        return ('ASSIGN', identifier, value)\r\n\r\n    def parse_expression(self):\r\n        # Placeholder for parsing expressions\r\n        # For now, assume simple arithmetic expressions\r\n        expr = []\r\n        while self.peek()[1] not in {')', ';'}:\r\n            token_type, token_value = self.peek()\r\n            if token_type in {'NUMBER', 'IDENTIFIER'}:\r\n                expr.append(token_value)\r\n            elif token_value in operators:\r\n                expr.append(token_value)\r\n            self.advance()  # Advance the token index here\r\n        return ' '.join(expr)\r\n\r\n    def parse_block(self):\r\n        block = []\r\n        self.consume('OPERATOR', '{')\r\n        while self.peek()[1] != '}':\r\n            block.append(self.parse_statement())\r\n        self.consume('OPERATOR', '}')\r\n        return block\r\n\r\n    def consume(self, expected_type, expected_value=None):\r\n        token_type, token_value = self.tokens[self.current_token_idx]\r\n        if token_type != expected_type or (expected_value is not None and token_value != expected_value):\r\n            self.error(\r\n                f\"Expected {expected_type}{' with value ' + expected_value if expected_value else ''}, got {token_type}{' with value ' + token_value if token_value else ''}\")\r\n        self.current_token_idx += 1\r\n        return token_type, token_value\r\n\r\n    def peek(self):\r\n        if self.current_token_idx < len(self.tokens):\r\n            return self.tokens[self.current_token_idx]\r\n        else:\r\n            return None, None\r\n\r\n    def advance(self):\r\n        self.current_token_idx += 1\r\n\r\n    def error(self, message):\r\n        raise SyntaxError(message)\r\n\r\n\r\nclass CodeGenerator:\r\n    def __init__(self, statements):\r\n        self.statements = statements\r\n\r\n    def generate_code(self):\r\n        output = []\r\n        indent_level = 0\r\n        for statement in self.statements:\r\n            if statement[0] == 'PRINT':\r\n                output.append(' '.join(map(str, statement[1])))\r\n            elif statement[0] == 'ASSIGN':\r\n                output.append(' ' * (indent_level * 2) + f'{statement[1]} = {statement[2]}')\r\n            elif statement[0] == 'IF':\r\n                output.append(' ' * (indent_level * 2) + f'if {statement[1]}:')\r\n                indent_level += 1\r\n                output.extend([' ' * (indent_level * 2) + line for line in statement[2]])\r\n                indent_level -= 1\r\n            elif statement[0] == 'REPEAT':\r\n                output.append(' ' * (indent_level * 2) + f'for _ in range({statement[1]}):')\r\n                indent_level += 1\r\n                output.extend([' ' * (indent_level * 2) + line for line in statement[2]])\r\n                indent_level -= 1\r\n        return '\\n'.join(output)\r\n\r\n\r\ndef compile_legend(code):\r\n    tokens = lex(code)\r\n    print(\"Lexed\")\r\n    parser = Parser(tokens)\r\n    print(\"Starting parser...\")\r\n    statements = parser.parse()\r\n    print(\"Parsed\")\r\n    code_generator = CodeGenerator(statements)\r\n    print(\"Generated\")\r\n    compiled_code = code_generator.generate_code()\r\n    print(\"Compiled\")\r\n    return compiled_code\r\n\r\n\r\n# Example usage\r\ncode = \"\"\"\r\nx = 5\r\nprint \"Hello, World!\"\r\n\"\"\"\r\n\r\nprint(\"Starting...\")\r\ncompiled_code = compile_legend(code)\r\nprint(\"Compiled Code:\")\r\nprint(compiled_code)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	
+++ b/main.py	
@@ -191,6 +191,7 @@
 code = """
 x = 5
 print "Hello, World!"
+y = 4
 """
 
 print("Starting...")
